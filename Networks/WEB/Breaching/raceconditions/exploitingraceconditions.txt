Click on the Start Machine button on the right to start the attached VM. Click on the Start AttackBox button at the top to start the AttackBox. On the AttackBox, browse to http://10.10.20.205:8080.

These are the credentials for two users:

User1: 07799991337
Password: pass1234
And

User2: 07113371111
Password: pass1234

This web application belongs to a mobile operator and allows phone credit transfer. In this demo, we will check if the system is susceptible to a race condition vulnerability and try to exploit it by transferring more credit than we have in our account.

First, we need to explore and study how the target web application receives HTTP requests and how it responds to them. Using Burp Suite Proxy, click Open browser under the Intercept tab. (If you get an error message about enabling the browser’s sandbox, you must manually change the settings. In this case, click Settings on the top right of your Burp Suite window, click on the Burp’s browser under Tools, and check Allow Burp’s browser to run without a sandbox.) Using the bundled browser, we can browse the target site and study how it processes our HTTP requests, notably the POST HTTP requests and related responses. The HTTP history tab logs every HTTP request and the respective response.

Log in to either of the accounts and click the Pay & Recharge button. Let’s make a credit transfer: click the Transfer button and enter the mobile number of the other account along with the amount you want to transfer. You can try to transfer an amount that exceeds your current balance and a small amount, such as $1, to see how the system responds in each case.

In the image below, we can see:

A POST request
The details show the target phone number and a transfer amount of $1.5
In the response, we can infer that the transaction is successful

Now that we have seen how the system reacts to valid and invalid requests, let’s see if we can exploit a race condition. Right-click on the POST request you want to duplicate and choose Send to Repeater.

In the Repeater tab, as shown in the numbered screenshots below:

Click on the + icon next to the received request tab and select Create tab group
Assign a group name, and include the tab of the request you just sent to the importer before clicking Create
Right-click on the request tab and choose Duplicate tab (If this option is not available in your version, you can press CTRL+R multiple times instead)
As a starting point, we will duplicate it 20 times
Next to the Send button, the arrow pointed downwards will bring a menu to decide how you want to send the duplicated requests

Next, we will exploit the target application by sending the duplicated request. Using the built-in options in Burp Suite Repeater, the drop-down arrow offers the following choices:

Send group in sequence (single connection)
Send group in sequence (separate connections)
Send group in parallel

Sending Request Group in Sequence
Sending the group in sequence provides two options:

Send group in sequence (single connection)
Send group in sequence (separate connections)

Send Group in Sequence over a Single Connection

This option establishes a single connection to the server and sends all the requests in the group’s tabs before closing the connection. This can be useful for testing for potential client-side desync vulnerabilities.

Send Group in Sequence over Separate Connections

As the name suggests, this option establishes a TCP connection, sends a request from the group, and closes the TCP connection before repeating the process for the subsequent request.

We tested this option to attack the web application. The screenshot below shows 21 TCP connections for the different POST requests in the group we sent.
The first group (labelled 1) comprises five successful requests. We could confirm that they were successful by checking the respective responses. Furthermore, we noticed that each took around 3 seconds, as indicated by the duration (labelled 3).
The second group (labelled 2) shows sixteen denied requests. The duration was around four milliseconds. It is interesting to check the Relative Start time as well.

The screenshot below shows the whole TCP connection for a request. We can confirm that the POST request was sent in a single packet.

Send Request Group in Parallel
Choosing to send the group’s requests in parallel would trigger the Repeater to send all the requests in the group at once. In this case, we notice the following, as shown in the screenshot below:

In the Relative Start column, we notice that all 21 packets were sent within a window of 0.5 milliseconds (labelled 1).
All 21 requests were successful; they resulted in a successful credit transfer. Each request took around 3.2 seconds to complete (labelled 2).

By paying close attention to the screenshot above, we notice that each request led to 12 packets; however, in the previous attempt (send in sequence), we see that each request required only 10 packets. Why did this happen?

According to Sending Grouped HTTP Requests documentation, when sending in parallel, Repeater implements different techniques to synchronize the requests’ arrival at the target, i.e., they arrive within a short time frame. The synchronization technique depends on the HTTP protocol being used:
In the case of HTTP/2+, the Repeater tries to send the whole group in a single packet. In other words, a single TCP packet would carry multiple requests.
In the case of HTTP/1, the Repeater resorts to last-byte synchronization. This trick is achieved by withholding the last byte from each request. Only once all packets are sent without the last-byte are the last-byte of all the requests sent. The screenshot below shows our POST request sent over two packets.


