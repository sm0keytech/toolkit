While different programming languages may use varying keywords and functions for serialisation, the underlying principle remainsdifferent serialisation methods in different languages consistent. As we know, serialisation is the process of converting an object's state into a format that can be easily stored or transmitted and then reconstructed later. Whether Java, Python, .NET, or PHP, each language implements serialisation to accommodate specific features or security measures inherent to its environment. 
Unlike other common vulnerabilities that exploit the immediate processing of user inputs, insecure deserialisation problems involve a deeper interaction with the application’s core logic, often manipulating the fundamental behaviour of its components.
Now, let's explore how serialisation is explicitly handled in different languages, exploring its functionality, syntax, and unique features.

PHP Serialisation
In PHP, serialisation is accomplished using the serialize() function. This function converts a PHP object or array into a byte stream representing the object's data and structure. The resulting byte stream can include various data types, such as strings, arrays, and objects, making it unique. To illustrate this, let's consider a notes application where users can save and retrieve their notes. We'll create a PHP class called Notes to represent each note and handle serialisation and deserialisation.

class Notes {
    public $Notescontent;

    public function __construct($content) {
        $this->Notescontent = $content;
    }
}
In our Notes application, when a user saves a note, we serialise the Notes class object using PHP's serialize() function. This converts the object into a string representation that can be stored in a file or database. Let's take a look at the following code snippet that serialises the Notes class object:

$note = new Notes("Welcome to THM");
$serialized_note = serialize($note);

Visit the link http://10.10.167.34/phptest/ and enter any string to serialise or deserialise. For example, if you enter the string Welcome to THM, it will generate the output O:5:"Notes":1:{s:7:"content";s:14:"Welcome to THM";} as shown below:
Let's decode the output:
O:5:"Notes":1:: This part indicates that the serialised data represents an object of the class Notes, which has one property.
s:7:"content": This represents the property name "content" with a length of 7 characters. In serialised data, strings are represented with s followed by the length of the string and the string in double quotes. Integers are represented with i followed by the numeric value without quotes.
s:14:"Welcome to THM": This is the value of the content property, with a length of 14 characters.

Magic Methods
PHP provides several magic methods that play crucial roles in the serialisation process. A few of the important methods are mentioned below:
__sleep(): This method is called on an object before serialisation. It can clean up resources, such as database connections, and is expected to return an array of property names that should be serialised.
__wakeup(): This method is invoked upon deserialisation. It can re-establish any connections that the object might need to operate correctly.
__serialize(): As of PHP 7.4, this method enables you to customise the serialisation data by returning an array representing the object's serialised form.
__unserialize(): This counterpart to __serialize() allows for customising the restoration of an object from its serialised data.

Python
Python uses a module called Pickle to serialise and deserialise objects. This module converts a Python object into a byte stream (and vice versa), enabling it to be saved to a file or transmitted over a network. Pickling is a powerful tool for Python developers because it handles almost all types of Python objects without needing any manual handling of the object's state. We will follow the same notes application in Python as in PHP. Here is the code snippet from the app.py class:

import pickle
import base64

...
serialized_data = request.form['serialized_data']
notes_obj = pickle.loads(base64.b64decode(serialized_data))
message = "Notes successfully unpickled."
...

elif request.method == 'POST':
    if 'pickle' in request.form:
        content = request.form['note_content']
        notes_obj.add_note(content)
        pickled_content = pickle.dumps(notes_obj)
        serialized_data = base64.b64encode(pickled_content).decode('utf-8')
        binary_data = ' '.join(f'{x:02x}' for x in pickled_content)
        message = "Notes pickled successfully."

Pickling Process
Creating a Notes class: This class manages a list of notes. It provides methods to add a note and retrieve all notes, making it easy to manage the application's state.
Serialisation (Pickling): When a user submits a note, the Notes class instance (including all notes) is serialised using pickle.dumps(). This function transforms the Python object into a binary format that Python can later turn back into an object.

Displaying the Serialised Data (Base64 Encoding)
Why use base64: Serialised data is binary and not safe for display in all environments. Binary data can contain bytes that maypickle.load pre-req in Python interfere with communication protocols (like HTTP). Base64 is an encoding scheme that converts binary data into plain text. It uses only readable characters, making it safe for transmission over channels that do not support binary data.
Encoding process: After serialising the Notes object, the binary data is encoded into a base64 string using base64.b64encode(). This string is safe to display in the HTML and easily stored or transmitted.

Deserialisation (Unpickling)
Base64 decoding: When unpickling, the base64 string is first decoded back into binary format using base64.b64decode().
Unpickling: The binary data is then passed to pickle.loads(), which reconstructs the original Python object from the binary stream.

Again, visit the link http://10.10.167.34:5000 and enter the string Welcome to THM:
Pickling: When this string is pickled, it is converted into a binary format that is not human-readable. This binary format contains information about the data type, the data itself, and other necessary metadata to reconstruct the object.
Base64 encoding: The binary form of the pickled data is then encoded into a Base64 string, which might look something like gASVIQAAAAAAAACMBFdlbGNvbWXCoGFkZYFdcQAu.

In exploring serialisation formats, we've discussed how this critical functionality is implemented in PHP and Python. PHP utilises the serialize() and unserialize() functions to manage the conversion of objects and other data types into a storable format that can be easily reconstructed. Similarly, Python employs the Pickle module to serialise objects into a byte stream and deserialise them back to their original state.
Beyond these two languages, serialisation is a common feature across various programming environments, each with unique implementations and libraries. In Java, object serialisation is facilitated through the Serializable interface, allowing objects to be converted into byte streams and vice versa, which is essential for network communication and data persistence. For .NET, serialisation has evolved significantly over the years. Initially, BinaryFormatter was commonly used for binary serialisation; however, its use is now discouraged due to security concerns. Modern .NET applications typically use System.Text.Json for JSON serialisation, or System.Xml.Serialization for XML tasks, reflecting a shift towards safer, more standardised data interchange formats. Ruby offers simplicity with its Marshal module, which is renowned for serialising and deserialising objects, and for more human-readable formats, it often utilises YAML. Each language’s approach to serialisation reflects its usage contexts and security considerations, highlighting the importance of understanding and properly implementing serialisation to ensure the integrity and security of data across web applications.


