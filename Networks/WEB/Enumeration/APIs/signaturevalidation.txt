Not Verifying the Signature

If the signature isn't correctly verified, a threat actor may be able to forge a valid JWT token to gain access to another user's account. Let's examine the common signature verification issues.

The first issue with signature validation is when there is no signature validation. If the server does not verify the signature of the JWT, then it is possible to modify the claims in the JWT to whatever you prefer them to be.

While it is uncommon to find APIs where no signature validation is performed, signature validation may have been omitted from a single endpoint within the API. Depending on the sensitivity of the endpoint, this can have a significant business impact.

Let's authenticate to the API:
curl -H 'Content-Type: application/json' -X POST -d '{ "username" : "user", "password" : "password2" }' http://10.10.22.190/api/v1.0/example2
Once authenticated, let's verify our user:
curl -H 'Authorization: Bearer [JWT Token]' http://10.10.22.190/api/v1.0/example2?username=user

However, let's try to verify our user without the signature, remove the third part of the JWT (leaving only the dot) and make the request again.
You will see that the verification still works! This means that the signature is not being verified. 
Modify the admin claim in the payload to be 1 and try to verify as the admin user to retrieve your flag.

curl -H 'Authorization: Bearer [JWT Token]' http://10.10.22.190/api/v1.0/example2?username=admin
Then we get the flag, and we got admin :))

The Development Mistake
In the example, the signature is not being verified, as shown below:
payload = jwt.decode(token, options={'verify_signature': False})
While it is rare to see this on normal APIs, it often happens on server-to-server APIs. In cases where a threat actor has direct access to the backend server, JWTs can be forged.

The Fix
The JWT should always be verified or additional authentication factors, such as certificates, should be used for server-to-server communication. The JWT can be verified by providing the secret (or public key), as shown in the example below:
payload = jwt.decode(token, self.secret, algorithms="HS256")


Downgrading to None
Another common issue is a signature algorithm downgrade.
JWTs support the None signing algorithm, which effectively means that no signature is used with the JWT. 
While this may sound silly, the idea behind this in the standard was for server-to-server communication, where the signature of the JWT was verified in an upstream process.
Therefore, the second server would not be required to verify the signature. However, suppose the developers do not lock in the signature algorithm or, at the very least, deny the None algorithm.
In that case, you can simply change the algorithm specified in your JWT as None, which would then cause the library used for signature verification to always return true, thus allowing you again to forge any claims within your token.

Practical Example 3
Authenticate to the API to receive your JWT and then verify your user.
To perform this attack, you will need to manually alter the  the alg claim in the header to be None.
You can use CyberChef for this making use of the URL-Encoded Base64 option. 
Submit the JWT again to verify that it is still accepted, even if the signature is no longer valid, as changes have been made. 
You can then alter the admin claim to recover the flag.

To do this, I used JWT.io to change the header and remove the encryption and replace it with none. It would'nt let me do it inside of JWT, so what I did was
get the JSON header file, pop it into cyberchef and base64 encode it. I then removed the equals sign padding. I also removed the square brackets from the second
query and it worked.

The Development Mistake
While this may seem like the same issue as before, from a development perspective, it is slightly more complex. Sometimes, developers want to ensure their implementation accepts several JWT signature verification algorithms. The implementation would then usually read the header of the JWT and parse found alg into the signature verification component, as shown below:
header = jwt.get_unverified_header(token)

signature_algorithm = header['alg']

payload = jwt.decode(token, self.secret, algorithms=signature_algorithm)

The Fix
If multiple signature algorithms should be supported, the supported algorithms should be supplied to the decode function as an array list, as shown below:
payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512"])

username = payload['username']
flag = self.db_lookup(username, "flag")

Weak Symmetric Secrets
If a symmetric signing algorithm is used, the security of the JWT relies on the strength and entropy of the secret used. If a weak secret is used, it may be possible to perform offline cracking to recover the secret. Once the secret value is known, you can again alter the claims in your JWT and recalculate a valid signature using the secret.

Practical Example 4
For this example, a weak secret was used to generate the JWT. Once you receive a JWT, you have several options to crack the secret. For our example, we will talk about using Hashcat to crack the JWT's secret. You could also use other solutions such as John as well. You can use the following steps to crack the secret:
Save the JWT to a text file called jwt.txt.
Download a common JWT secret list. For this room, you can use wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list to download such a list.
Use Hashcat to crack the secret using hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list

After cracking, I found out that it was "secret". Now, we can forge an admin token with this key we have.
We can then head back to JWT.io, and the pop in the word secret into the correct area, and forge the rest to get our admin token.
Once we have our new token, we can just send it back into the system using the thing we did before.

Signature Algorithm Confusion
The last common issue with signature validation is when an algorithm confusion attack can be performed. This is similar to the None downgrade attack, however, it specifically happens with confusion between symmetric and asymmetric signing algorithms.
If an asymmetric signing algorithm, for example, RS256 is used, it may be possible to downgrade the algorithm to HS256. In these cases, some libraries would default back to using the public key as the secret for the symmetric signing algorithm.
Since the public key can be known, you can forge a valid signature by using the HS256 algorithm in combination with the public key.

Practical Example 5
This is similar to example 3. Except this time, the None algorithm is not allowed.
However, once you authenticate to the example, you will also receive the public key. As the public key isn't regarded as sensitive, it is common to find the public key.
Sometimes, the public key is even embedded as a claim in the JWT. In this example, you must downgrade the algorithm to HS256 and then use the public key as the secret to sign the JWT.
You can use the script provided below to assist you in forging this JWT:

import jwt

public_key = "ADD_KEY_HERE"

payload = {
    'username' : 'user',
    'admin' : 0
}

access_token = jwt.encode(payload, public_key, algorithm="HS256")
print (access_token)

Before running the script, edit the file /usr/lib/python3/dist-packages/jwt/algorithms.py using your favorite text editor and go to line 143. 
Then proceed to comment out lines 143-146 and run the script. If you are using your own VM, you may have to install Pyjwt (pip3 install pyjwt) to use this script.
You will also need to tamper with the Pyjwt library's algorithm.py file on line 258 to remove the is_ssh_key condition as a patch for this vulnerability was released.
Keep in mind that this placement can vary per VM and installation. 
An easier method if you are not comfortable with library code edits is to make use of jwt.io.
Once you verify it works, you can alter the claims to make yourself an admin and recover the flag.

curl -H 'Content-Type: application/json' -X POST -d '{ "username" : "user", "password" : "password5" }' http://10.10.22.190/api/v1.0/example5
