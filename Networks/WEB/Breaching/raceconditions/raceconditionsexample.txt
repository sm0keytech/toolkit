Real World Analogy
Picture the following situation. You call a restaurant to reserve a table for a crucial business lunch. You are familiar with the restaurant and its setup. One particular table, number 17, is your preferred choice, considering it has a nice view and is relatively isolated. You call to make a reservation for Table 17; the host confirms it is free as no “Reserved” tag is placed on it. At the same time, another customer is talking with another host and making a reservation for the same table.

Who really reserved the table? That’s a race condition.
Why did this happen? This unlucky situation happened because more than one host was taking reservations; furthermore, it took the host a few minutes to fetch the “Reserved” tag and put it on the table after updating the daily reservation book. There is at least a one-minute window for another client to reserve a reserved table.
Similarly, when one thread checks a value to perform an action, another thread might change that value before the action takes place.

Example A
Let’s consider this scenario:
A bank account has $100.
Two threads try to withdraw money at the same time.
Thread 1 checks the balance (sees $100) and withdraws $45.
Before Thread 1 updates the balance, Thread 2 also checks the balance (incorrectly sees $100) and withdraws $35.

We cannot be 100% certain which thread will get to update the remaining balance first; however, let’s assume that it is Thread 1. Thread 1 will set the remaining balance to $55. Afterwards, Thread 2 might set the remaining balance to $65 if not appropriately handled. (Thread 2 calculated that $65 should remain in the account after the withdrawal because the balance was $100 when Thread 2 checked it.) In other words, the user made two withdrawals, but the account balance was deducted only for the second one because Thread 2 said so!

Example B
Let’s consider another scenario:
A bank account has $75.
Two threads try to withdraw money at the same time.
Thread 1 checks the balance (sees $75) and withdraws $50.
Before Thread 1 updates the balance, Thread 2 checks the balance (incorrectly sees $75) and withdraws $50.

Thread 2 will proceed with the withdrawal, although such a transaction should have been declined.
Examples A and B demonstrate a Time-of-Check to Time-of-Use (TOCTOU) vulnerability.

Example Code
Consider the following Python code with two threads simulating a task completion by 10% increments.

import threading
import time

def increase_by_10():
    for i in range(1, 11):
        print(f"Thread {threading.current_thread().name}: {i}0% complete")

# Create two threads
thread1 = threading.Thread(target=increase_by_10, name="Thread-1")
thread2 = threading.Thread(target=increase_by_10, name="Thread-2")

# Start the threads
thread1.start()
thread2.start()

# Wait for both threads to finish
thread1.join()
thread2.join()

print("Both threads have finished completely.")

These two threads start together; they do nothing except print a value on the screen. Consequently, one would expect them to finish simultaneously, or at least the result to be consistent. However, in the program above, there is no guarantee which thread will finish first and how early it will be. Below is the first execution output:
python t3_race_to_100.py
...
Thread Thread-1: 50% complete
Thread Thread-2: 90% complete
Thread Thread-2: 100% complete
Thread Thread-1: 60% complete
Thread Thread-1: 70% complete
Thread Thread-1: 80% complete
Thread Thread-1: 90% complete
Thread Thread-1: 100% complete
Both threads have finished completely.

Below is a second execution output:
python t3_race_to_100.py 
...
Thread Thread-1: 90% complete
Thread Thread-1: 100% complete
Thread Thread-2: 10% complete
Thread Thread-2: 20% complete
Thread Thread-2: 30% complete
Thread Thread-2: 40% complete
Thread Thread-2: 50% complete
Thread Thread-2: 60% complete
Thread Thread-2: 70% complete
Thread Thread-2: 80% complete
Thread Thread-2: 90% complete
Thread Thread-2: 100% complete
Both threads have finished completely.

Running this program multiple times will lead to different results. In the first attempt, Thread-2 reached 100 first; however, in the second attempt, Thread-2 reached 100 second. We have no control over the output. If the security of our application relies on one thread finishing before the other, then we need to set mechanisms in place to ensure proper protection. Consider the following two examples to better understand the bugs’ gravity when we leave things to chance.

On the AttackBox, you can save the above Python code and run it multiple times to observe the outcome. For instance, if you saved it as race.py, you can run the script using the python race.py command.

Causes
As we saw in the last program, two threads were changing the same variable. Whenever the thread was given CPU time, it rushed to change the value according to its instructions. Consequently, these two threads were “racing” to increase the value to 100. This program shows a straightforward example happening on a single host.

Generally speaking, a common cause of race conditions lies in shared resources. For example, when multiple threads concurrently access and modify the same shared data. Examples of shared data are a database record and an in-memory data structure. There are many subtle causes, but we will mention three common ones:
Parallel Execution: Web servers may execute multiple requests in parallel to handle concurrent user interactions. If these requests access and modify shared resources or application states without proper synchronization, it can lead to race conditions and unexpected behaviour.
Database Operations: Concurrent database operations, such as read-modify-write sequences, can introduce race conditions. For example, two users attempting to update the same record simultaneously may result in inconsistent data or conflicts. The solution lies in enforcing proper locking mechanisms and transaction isolation.
Third-Party Libraries and Services: Nowadays, web applications often integrate with third-party libraries, APIs, and other services. If these external components are not designed to handle concurrent access properly, race conditions may occur when multiple requests or operations interact with them simultaneously.


